<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Template</title>
	<style type="text/css">
	canvas{
		border:1px solid gray;
	}
	
	#audioControls{
		display:none;
	}
	</style>
	<script src="js/utilities.js"></script>
	<script>
		"use strict";
		(function(){
		//fsdfasdfasdfSdf
		var canvas, ctx;
		//var x,y,radius,xSpeed,ySpeed,fillStyle;
		var CANVAS_WIDTH = 640, CANVAS_HEIGHT = 480;
		// CONSTANTS
		var START_RADIUS = 8;
		var MAX_SPEED = 40;
		var MAX_RADIUS = 45;
		var MIN_RADIUS = 2;
		var MAX_LIFETIME = 5;
		var EXPLOSION_SPEED = 30;
		var IMPLOSION_SPEED = 42;
		var CIRCLE_STATE_NORMAL = 0;
		var CIRCLE_STATE_EXPLODING = 1;
		var CIRCLE_STATE_MAX_SIZE = 2;
		var CIRCLE_STATE_IMPLODING = 3;
		var CIRCLE_STATE_DONE = 4;
		var GAME_STATE_BEGIN = 0;
		var GAME_STATE_DEFAULT = 1;
		var GAME_STATE_EXPLODING = 2;
		var GAME_STATE_ROUND_OVER = 3;
		var GAME_STATE_END = 4;
		var GAME_STATE_REPEAT_LEVEL = 5;
		var NUM_CIRCLES_START = 50;
		var NUM_CIRCLES_END = NUM_CIRCLES_START + 30;
		var PERCENT_GIRCLES_LEVEL_INCREASE = 0.85;

		// one new variable
		var numCircles = NUM_CIRCLES_START;
		
		var gameState = GAME_STATE_BEGIN;
		var roundScore;
		var totalScore = 0;

		var circles = [];
		var paused = false;
		var animationID;
		
		var lastTime = 0;
		
		var bgAudio;
		var winAudio;
		var effectAudio;
		var currentEffect = 0;
		var currentDirection = 1;
		var effectSounds = ["1.mp3", "2.mp3", "3.mp3", "4.mp3", "5.mp3", "6.mp3", "7.mp3", "8.mp3"];
		
		var winPlayed;
		
		var gameSpeed = 1;
		
		window.onload = init;
	
		function init(){
			console.log("init called");
			canvas = document.querySelector("canvas");
			ctx = canvas.getContext("2d");
			
			bgAudio = document.querySelector('#bgAudio');
			bgAudio.volume = 0.25;
			
			winAudio = document.querySelector('#winAudio');
			winAudio.volume = 0.25;
			
			effectAudio = document.querySelector('#effectAudio');
			effectAudio.volume = 0.3;
			
			reset();
			
			window.onblur = function(){
				stopAudio();
				//paused = true;
				//cancelAnimationFrame(animationID);
				//update();
			};
			
			window.onfocus = function(){
				bgAudio.play();
				//cancelAnimationFrame(animationID);
				//paused = false;
				//update();
			};
			
			canvas.onmousedown = doMouseDown;
			
			update();
		}
		
		function reset()
		{
			numCircles += 5;
			roundScore = 0;
			circles = makeCircles(numCircles);
			winPlayed = false;
			gameSpeed = 1;
		}
		
		function update()
		{
			//debugger;
			var dt = calculateDeltaTime();
			
			if(paused)
			{
				drawPauseScreen();
				return;
			}
			animationID = requestAnimationFrame(update);
			
			moveCircles(dt);
			
			checkForCollisions();
			
			ctx.fillStyle = "black";
			ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
			
			ctx.globalAlpha = 0.9;
			drawCircles();
			
			ctx.globalAlpha = 1.0;
			drawHUD();
			
			//drawText("dt: " + dt.toFixed(3), 200, 450, 24, "red");
		}
		
		function circleHitLeftRight(x,y,radius)
		{
			return (x < radius || x > CANVAS_WIDTH - radius);
		}
		
		function circleHitTopBottom(x,y,radius)
		{
			return (y < radius || y > CANVAS_HEIGHT - radius);
		}
		
		function drawText(string, x, y, size, color)
		{
			ctx.font = 'bold ' + size + 'px Monospace';
			ctx.fillStyle = color;
			ctx.fillText(string, x, y);
		}
		
		function makeCircles(num)
		{
			var array = [];
			for (var i = 0; i < num; i++)
			{
				var c = {};
				c.x = getRandom(START_RADIUS * 2, CANVAS_WIDTH - START_RADIUS * 2);
				c.y = getRandom(START_RADIUS * 2, CANVAS_HEIGHT - START_RADIUS * 2);
				c.radius = START_RADIUS;
				var randomVector = getRandomUnitVector();
				c.xSpeed = randomVector.x;
				c.ySpeed = randomVector.y;
				c.speed = MAX_SPEED;
				c.fillStyle = getRandomColor();
				c.state = CIRCLE_STATE_NORMAL;
				c.lifetime = 0;
				c.move = _circleMove;
				array.push(c);
			}
			return array;
		}
		
		var _circleMove = function(dt)
		{
			this.x += this.xSpeed * this.speed * dt * gameSpeed;
			this.y += this.ySpeed * this.speed * dt * gameSpeed;
		}
		
		function doMouseDown(e)
		{
			bgAudio.play();
			
			if(paused)
			{
				paused = false;
				update();
				return;
			}
			if(gameState == GAME_STATE_EXPLODING)
			{
				gameSpeed *= 1.3;
				if(gameSpeed > 8)
				{
					gameSpeed = 8;
				}
				return;
			}
			if(gameState == GAME_STATE_ROUND_OVER)
			{
				gameState = GAME_STATE_DEFAULT;
				reset();
				return;
			}
			if(gameState == GAME_STATE_REPEAT_LEVEL)
			{
				gameState = GAME_STATE_DEFAULT;
				numCircles -= 5;
				reset();
				return;
			}
			if(gameState == GAME_STATE_END)
			{
				gameState = GAME_STATE_BEGIN;
				totalScore = 0;
				numCircles = NUM_CIRCLES_START;
				reset();
				return;
			}
			var mouse = getMouse(e);
			var c = {};
			c.x = mouse.x;
			c.y = mouse.y;
			c.radius = START_RADIUS;
			var randomVector = getRandomUnitVector();
			c.xSpeed = randomVector.x;
			c.ySpeed = randomVector.y;
			c.speed = MAX_SPEED;
			c.fillStyle = getRandomColor();
			c.state = CIRCLE_STATE_NORMAL;
			c.lifetime = 0;
			c.move = _circleMove;
			circles.push(c);
			roundScore -= 1;
			for(var i = circles.length - 1; i >= 0; i--)
			{
				var c = circles[i];
				if(pointInsideCircle(mouse.x, mouse.y, c))
				{
					circleClicked(c);
					break;
				}
			}
		}
		
		
		function circleClicked(circle)
		{
			playEffect();
			circle.state = CIRCLE_STATE_EXPLODING;
			circle.xSpeed = circle.ySpeed = 0;
			gameState = GAME_STATE_EXPLODING;
			roundScore++;
		}
		
		function drawPauseScreen()
		{
			ctx.save();
			ctx.fillStyle = "black";
			ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			drawText("... PAUSED ...", CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 60, "white");
			ctx.restore();
		}
		
		function moveCircles(dt)
		{
			for (var i = 0; i < circles.length; i++)
			{
				var c = circles[i];
				
				if(c.state === CIRCLE_STATE_DONE)
				{
					continue;
				}
				
				if(c.state === CIRCLE_STATE_EXPLODING)
				{
					c.radius += EXPLOSION_SPEED * dt * gameSpeed;
					if (c.radius >= MAX_RADIUS)
					{
						c.state = CIRCLE_STATE_MAX_SIZE;
						//console.log("circle #" + i + " hit MAX_RADIUS");
					}
					continue;
				}
				
				if(c.state === CIRCLE_STATE_MAX_SIZE)
				{
					c.lifetime += dt * gameSpeed;
					if(c.lifetime >= MAX_LIFETIME)
					{
						c.state = CIRCLE_STATE_IMPLODING;
						//console.log("circle #" + i + " hit MAX_LIFETIME");
					}
					continue;
				}	
				
				if(c.state === CIRCLE_STATE_IMPLODING)
				{
					c.radius -= IMPLOSION_SPEED  * dt * gameSpeed;
					if (c.radius <= MIN_RADIUS)
					{
						//console.log("circle #" + i + " hit MIN_RADIUS and is gone");
						c.state = CIRCLE_STATE_DONE;
					}
					continue;
				}
				
				c.move(dt);
				
				if (circleHitLeftRight(c.x, c.y, c.radius))
				{
					c.xSpeed *= -1;
				}
				if (circleHitTopBottom(c.x, c.y, c.radius))
				{
					c.ySpeed *= -1;
				}
			}
		}
		
		function checkForCollisions()
		{
			if(gameState == GAME_STATE_EXPLODING)
			{
				for (var i = 0; i < circles.length; i++)
				{
					var c1 = circles[i];
					if (c1.state == CIRCLE_STATE_NORMAL)
					{
						continue;
					}
					if (c1.state == CIRCLE_STATE_DONE)
					{
						continue;
					}
					for (var j = 0; j < circles.length; j++)
					{
						var c2 = circles[j];
						if (c1 == c2)
						{
							continue;
						}
						if (c2.state != CIRCLE_STATE_NORMAL)
						{
							continue;
						}
						if (c2.state === CIRCLE_STATE_DONE)
						{
							continue;
						}
						if(circlesIntersect(c1,c2))
						{
							playEffect();
							c2.state = CIRCLE_STATE_EXPLODING;
							c2.xSpeed = c2.ySpeed = 0;
							roundScore++;
							if (roundScore >= Math.floor(numCircles * PERCENT_GIRCLES_LEVEL_INCREASE) && !winPlayed)
							{
								winAudio.play();
								winPlayed = true;
							}
						}
					}
				}
				
				var isOver = true;
				for (var i = 0; i < circles.length; i++)
				{
					var c = circles[i];
					if (c.state != CIRCLE_STATE_NORMAL && c.state != CIRCLE_STATE_DONE)
					{
						isOver = false;
						break;
					}
				}
				if(isOver)
				{
					if(roundScore < Math.floor(numCircles * PERCENT_GIRCLES_LEVEL_INCREASE))
					{
						gameState = GAME_STATE_REPEAT_LEVEL;
					}
					else
					{
						gameState = GAME_STATE_ROUND_OVER;
						totalScore += roundScore;
						stopAudio();
						if(numCircles >= NUM_CIRCLES_END)
						{
							gameState = GAME_STATE_END;
						}
					}
				}
			}
		}
		
		function drawCircles()
		{
			if(gameState == GAME_STATE_END)
			{
				ctx.globalAlpha = 0.5;
			}
			for (var i = 0; i < circles.length; i++)
			{
				var c = circles[i];
				if(c.state != CIRCLE_STATE_DONE)
				{
					ctx.beginPath();
					ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2, false);
					ctx.closePath();
					ctx.fillStyle = c.fillStyle;
					ctx.fill();
				}
			}
		}
		
		function drawHUD(){
			// draw score
			// drawText(string, x, y, size, color)
			drawText("This Round: " + roundScore + "/" + Math.floor(numCircles * PERCENT_GIRCLES_LEVEL_INCREASE) + " of " + numCircles, 20, 20, 16, "#ddd");
			drawText("Total Score: " + totalScore, CANVAS_WIDTH - 200, 20, 16, "#ddd");
			
			if(gameState == GAME_STATE_BEGIN){
				ctx.save();
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				drawText("To begin, click a circle", CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 34, "white");
				ctx.restore();
			} // end if
			
			if(gameState == GAME_STATE_ROUND_OVER){
				ctx.save();
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				drawText("Round Over", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40, 34,	 "red");
				drawText("Click to continue", CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 34, "red");
				drawText("Next round there are " + (numCircles + 5) + " circles", CANVAS_WIDTH/2 , CANVAS_HEIGHT/2 + 35, 24, "#ddd");
				
				ctx.restore();
			}
			
			if(gameState == GAME_STATE_REPEAT_LEVEL){
				ctx.save();
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				drawText("You missed the goal of " + Math.floor(numCircles * PERCENT_GIRCLES_LEVEL_INCREASE) + " circles", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40, 24,	"#ddd");
				drawText("Click to repeat level", CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 34, "red");
				drawText("Goal: " + Math.floor(numCircles * PERCENT_GIRCLES_LEVEL_INCREASE) + " of " + numCircles + " circles", CANVAS_WIDTH/2 , CANVAS_HEIGHT/2 + 35, 24, "#ddd");
				
				ctx.restore();
			}
			
			if(gameState == GAME_STATE_END){
				ctx.save();
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				drawText("Game Over", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40, 34,	 "red");
				drawText("Click to restart", CANVAS_WIDTH/2, CANVAS_HEIGHT/2, 34, "red");
				drawText("Your final score was " + totalScore + "!", CANVAS_WIDTH/2 , CANVAS_HEIGHT/2 + 35, 24, "#ddd");
				
				ctx.restore();
			} // end if
		} // end function
		
		function calculateDeltaTime()
		{
			var now;
			var fps;
			now = (+new Date);
			fps = 1000 / (now - lastTime);
			fps = clamp(fps, 12, 60);
			lastTime = now;
			return 1/fps;
		}
		
		function stopAudio()
		{
			bgAudio.pause();
			bgAudio.currentTime = 0;
		}
		
		function playEffect()
		{
			effectAudio.src = "media/" + effectSounds[currentEffect];
			effectAudio.play();
			
			currentEffect = currentEffect + currentDirection;
			if(currentEffect == effectSounds.length || currentEffect == -1)
			{
				currentDirection *= -1;
				currentEffect += currentDirection;
			}
		}
		}())
	</script>
</head>
<body>
	<canvas width="640" height="480">
		
	</canvas>
	<section id="audioControls">
		<audio id="bgAudio" src="media/background.mp3" controls loop></audio>
		<audio id="effectAudio" controls></audio>
		<audio id="winAudio" src="media/level-complete.mp3" controls></audio>
	</section>
</body>
</html>
